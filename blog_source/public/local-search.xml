<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>级联阴影贴图实现</title>
    <link href="/2024/10/13/cascade-shadow-map/"/>
    <url>/2024/10/13/cascade-shadow-map/</url>
    
    <content type="html"><![CDATA[<h1 id="阴影贴图的局限"><a href="#阴影贴图的局限" class="headerlink" title="阴影贴图的局限"></a>阴影贴图的局限</h1><p>阴影贴图（shadow map）是3D场景中实现阴影效果的基础手段，它通过预先将光线方向的场景深度存储到贴图中，在渲染的时候取每个场景中的点到光源的距离和深度贴图作比较，来判定该点是否在阴影当中。</p><p>但是在较大的场景中，使用阴影贴图会有几个明显的不足：</p><ol><li>阴影贴图只能覆盖部分场景，在渲染较大的场景的时候（如大世界），远处的场景基本上无法被阴影贴图所覆盖。</li><li>贴图的分辨率是有限的，太大的分辨率会对性能造成非常大的影响。但是在覆盖较大场景的时候，贴图分辨率不足会导致阴影模糊，效果不佳。</li><li>阴影贴图的实现一开始其实并没有考虑玩家相机的视椎体，也就是说在玩家没有看的地方也会渲染阴影贴图，这对渲染资源来说显然是个浪费。</li></ol><p>KongEngine计划在后面接入大地形的渲染，借此机会接入了级联阴影贴图的能力。<br>实现方法参考了<a href="https://learnopengl.com/Guest-Articles/2021/CSM">LearnOpenGL的教程</a>。</p><h1 id="级联阴影贴图的实现"><a href="#级联阴影贴图的实现" class="headerlink" title="级联阴影贴图的实现"></a>级联阴影贴图的实现</h1><p>级联阴影贴图的基本概念包括如下几点：</p><ol><li>将玩家的视椎体划分为几段，每一段视椎体构建一张阴影贴图覆盖，这个阴影贴图完美贴合从光源方向投射到这段视椎体中心点的正交投影。</li><li>和模型LOD的理念类似，离相机近的阴影贴图需要采用较高精度，而离相机远的阴影贴图可以使用低精度。</li><li>将多级阴影贴图传入最后的光照计算着色器，根据每个点所处视椎体的分段不同采用对应不同的阴影贴图计算光照。</li></ol><p>听起来挺简单的对吧，那我们一步一步来。</p><h2 id="视椎体分段"><a href="#视椎体分段" class="headerlink" title="视椎体分段"></a>视椎体分段</h2><p>上面说到我们需要将视椎体分为几段，在每一段视椎体覆盖一张阴影贴图，并计算出这张贴图的从光源方向看向视椎体中心点的正交投影的矩阵，也就是Light projection matrix和Light view matrix。这个矩阵需要紧密贴合这段视椎体，为此我们需要得到视椎体的顶点的世界坐标，得到顶点的min、max和视椎体的中心点。</p><p>我们从相机的视椎体出发，当处于视椎体范围上的顶点的世界坐标经过projection矩阵和view矩阵转换后，xyz都会被映射到[-1,1]范围的屏幕空间坐标。矩阵转换是可逆的，也就是说取屏幕空间坐标为[-1, 1]边界的八个顶点，经过视椎体的projection矩阵和view矩阵的逆矩阵转换后，就能得到边界顶点的世界空间坐标。在代码里面的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">std::vector&lt;glm::vec4&gt; <span class="hljs-title">CDirectionalLightComponent::GetFrustumCornersWorldSpace</span><span class="hljs-params">(<span class="hljs-type">const</span> glm::mat4&amp; proj_view)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> inv = glm::<span class="hljs-built_in">inverse</span>(proj_view);<br><br>    <span class="hljs-comment">// 顶点的世界坐标在projection和view matrix的转换下的坐标范围是[-1,1]</span><br>    <span class="hljs-comment">// 那么将在[-1,1]这个边界的八个顶点坐标乘以projection和view matrix的逆矩阵则可以得到视锥体边界的顶点的世界坐标</span><br>    vector&lt;vec4&gt; frustum_corners;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">2</span>; j++)<br>        &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">2</span>; k++)<br>            &#123;<br>                <span class="hljs-type">const</span> vec4 pt = inv * <span class="hljs-built_in">vec4</span>(<span class="hljs-number">2.0f</span>*i<span class="hljs-number">-1.0f</span>,<span class="hljs-number">2.0f</span>*j<span class="hljs-number">-1.0f</span>,<span class="hljs-number">2.0f</span>*k<span class="hljs-number">-1.0f</span>, <span class="hljs-number">1.0f</span>);<br>                frustum_corners.<span class="hljs-built_in">push_back</span>(pt / pt.w);<br>            &#125;<br>        &#125;   <br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> frustum_corners;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们得到了视椎体角落的顶点世界坐标，我们希望阴影贴图能够如下图一般贴合每一段视椎体。那么我们需要计算视椎体的中心顶点坐标，中心顶点在计算view矩阵的时候需要用到；我们需要计算在xyz轴上顶点坐标的最大和最小值，这些数值在计算projection矩阵的时候会被用到。</p><p><img src="https://learnopengl.com/img/guest/2021/CSM/frustum_fitting.png" alt="级联阴影贴图由远及近"></p><p>计算中心点的代码十分简单，将视椎体角落的坐标相加后再除以数量即可，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++">vec3 center = <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v : corners)<br>&#123;<br>    center += <span class="hljs-built_in">vec3</span>(v);<br>&#125;<br>center /= corners.<span class="hljs-built_in">size</span>();   <span class="hljs-comment">// 获取视锥体的中心点</span><br><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> light_view = <span class="hljs-built_in">lookAt</span>(center-light_dir, center, <span class="hljs-built_in">vec3</span>(<span class="hljs-number">0.0f</span>, <span class="hljs-number">1.0f</span>, <span class="hljs-number">0.0f</span>));<br></code></pre></td></tr></table></figure><p>计算贴合视椎体的范围则是比较并记录各个顶点在xyz轴的最大值和最小值，方法如下。这里提一下在z轴方向和一个参数z_mult进行了处理，其意义是阴影的投射源是有可能在视椎体范围之外的，如果不考虑这一部分的影响的话可能在阴影过度的时候会非常生硬，并且丢掉一些本来该显示的阴影导致渲染错误。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">float</span> min_x = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>();<br><span class="hljs-type">float</span> min_y = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>();<br><span class="hljs-type">float</span> min_z = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">max</span>();<br><span class="hljs-type">float</span> max_x = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">lowest</span>();<br><span class="hljs-type">float</span> max_y = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">lowest</span>();<br><span class="hljs-type">float</span> max_z = std::numeric_limits&lt;<span class="hljs-type">float</span>&gt;::<span class="hljs-built_in">lowest</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; v : corners)<br>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> trf = light_view * v;<br>    min_x = std::<span class="hljs-built_in">min</span>(min_x, trf.x);<br>    max_x = std::<span class="hljs-built_in">max</span>(max_x, trf.x);<br>    min_y = std::<span class="hljs-built_in">min</span>(min_y, trf.y);<br>    max_y = std::<span class="hljs-built_in">max</span>(max_y, trf.y);<br>    min_z = std::<span class="hljs-built_in">min</span>(min_z, trf.z);<br>    max_z = std::<span class="hljs-built_in">max</span>(max_z, trf.z);<br>&#125;<br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">float</span> z_mult = <span class="hljs-number">10.0f</span>;<br><span class="hljs-keyword">if</span> (min_z &lt; <span class="hljs-number">0</span>)<br>&#123;<br>    min_z *= z_mult;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    min_z /= z_mult;<br>&#125;<br><span class="hljs-keyword">if</span> (max_z &lt; <span class="hljs-number">0</span>)<br>&#123;<br>    max_z /= z_mult;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    max_z *= z_mult;<br>&#125;<br><br><span class="hljs-type">const</span> mat4 light_projection = <span class="hljs-built_in">ortho</span>(min_x, max_x, min_y, max_y, min_z, max_z);<br></code></pre></td></tr></table></figure><h2 id="计算级联阴影贴图"><a href="#计算级联阴影贴图" class="headerlink" title="计算级联阴影贴图"></a>计算级联阴影贴图</h2><p>一般的阴影贴图我们采用的是GL_TEXTURE_2D，而级联阴影贴图我们需要传入多张贴图，因此对应的贴图类型会变为GL_TEXTURE_2D_ARRAY。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">glGenTextures</span>(<span class="hljs-number">1</span>, &amp;csm_texture);<br><span class="hljs-built_in">glBindTexture</span>(GL_TEXTURE_2D_ARRAY, csm_texture);<br><span class="hljs-built_in">glTexImage3D</span>(GL_TEXTURE_2D_ARRAY, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT32F, SHADOW_RESOLUTION, SHADOW_RESOLUTION, (<span class="hljs-type">int</span>)csm_distances.<span class="hljs-built_in">size</span>()<span class="hljs-number">+1</span>, <span class="hljs-number">0</span>, GL_DEPTH_COMPONENT, GL_FLOAT, <span class="hljs-literal">nullptr</span>);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MAG_FILTER, GL_NEAREST);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_MIN_FILTER, GL_NEAREST);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_BORDER);<br><span class="hljs-built_in">glTexParameteri</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_BORDER);<br><span class="hljs-built_in">glTexParameterfv</span>(GL_TEXTURE_2D_ARRAY, GL_TEXTURE_BORDER_COLOR, border_color);<br><br><span class="hljs-built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, shadowmap_fbo);<br><span class="hljs-built_in">glFramebufferTexture</span>(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, csm_texture, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">glDrawBuffer</span>(GL_NONE);<br><span class="hljs-built_in">glReadBuffer</span>(GL_NONE);<br><span class="hljs-built_in">glBindFramebuffer</span>(GL_FRAMEBUFFER, <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p>除此之外，我们需要一次性渲染多张贴图，我们参考点光源阴影贴图使用geometry shader的做法，将顶点映射到不同的视椎体分段的光源的投影。代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-meta">#version 450 compatibility</span><br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">triangles</span>, <span class="hljs-keyword">invocations</span> = <span class="hljs-number">6</span>) <span class="hljs-keyword">in</span>;<br><span class="hljs-keyword">layout</span>(<span class="hljs-keyword">triangle_strip</span>, <span class="hljs-keyword">max_vertices</span> = <span class="hljs-number">3</span>) <span class="hljs-keyword">out</span>;<br><br><span class="hljs-keyword">uniform</span> <span class="hljs-type">mat4</span> light_space_matrix[<span class="hljs-number">16</span>];<br><br><br><span class="hljs-type">void</span> main()<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; ++i)<br>&#123;<br><span class="hljs-built_in">gl_Position</span> = light_space_matrix[<span class="hljs-built_in">gl_InvocationID</span>] * <span class="hljs-built_in">gl_in</span>[i].<span class="hljs-built_in">gl_Position</span>;<br><span class="hljs-built_in">gl_Layer</span> = <span class="hljs-built_in">gl_InvocationID</span>;<br><span class="hljs-built_in">EmitVertex</span>();<br>&#125;<br><span class="hljs-built_in">EndPrimitive</span>();<br>&#125; <br></code></pre></td></tr></table></figure><p>这里新增的<strong>invocations &#x3D; 6</strong>代表了这个Shader可以被实例化，每个实例同时平行进行运算，实例的个数为6。内置的<strong>gl_InvocationID</strong>代表了当前处理的是哪一个实例，我们将其赋值到<strong>gl_Layer</strong>。其余的阴影贴图渲染步骤和普通的阴影贴图类似。</p><p>下面几张图所示展示的，就是从近到远的几个级联阴影贴图的表现：<br><img src="/2024/10/13/cascade-shadow-map/csm_near.png"><br><img src="/2024/10/13/cascade-shadow-map/csm_mid.png"><br><img src="/2024/10/13/cascade-shadow-map/csm_far.png"></p><h2 id="使用级联阴影贴图"><a href="#使用级联阴影贴图" class="headerlink" title="使用级联阴影贴图"></a>使用级联阴影贴图</h2><p>级联阴影贴图的使用和阴影贴图是类似的，由于传入给光照Shader的是GL_TEXTURE_2D_ARRAY，需要使用vec3来索引贴图数据的，vec3的z值代表的是Layer索引。</p><p>Layer代表的是使用哪一个视椎体分段的阴影贴图，取决于当前像素和相机的距离。取得对应的Layer参数后带入texcoord的z值读取对应的阴影贴图的值。示例代码如下：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs glsl"><span class="hljs-comment">// 计算阴影</span><br><span class="hljs-type">float</span> ShadowCalculation_DirLight(<span class="hljs-type">vec4</span> frag_world_pos, <span class="hljs-type">vec3</span> to_light_dir, <span class="hljs-type">vec3</span> in_normal)<br>&#123;<br>    <span class="hljs-comment">// 获取像素和相机的距离，也就是view转换后的z值</span><br>    <span class="hljs-type">vec4</span> frag_pos_view_space = matrix_ubo.view * frag_world_pos;<br>    <span class="hljs-type">float</span> depthValue = <span class="hljs-built_in">abs</span>(frag_pos_view_space.z);<br><br>    <span class="hljs-comment">// 根据距离和每段视椎体分段的距离区间，获取Layer值</span><br>    <span class="hljs-type">int</span> layer = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; csm_level_count; ++i)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (depthValue &lt; csm_distances[i])<br>        &#123;<br>            layer = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (layer == <span class="hljs-number">-1</span>)<br>    &#123;<br>        layer = csm_level_count;<br>    &#125;<br>    <span class="hljs-comment">// 下面的和应用普通阴影贴图的一致</span><br>    <span class="hljs-comment">// 转换到-1,1的范围，再转到0,1的范围</span><br>    <span class="hljs-type">vec4</span> frag_pos_light_space = light_space_matrices[layer] * frag_world_pos;<br>    <span class="hljs-comment">// perform perspective divide</span><br>    <span class="hljs-type">vec3</span> proj_coord = frag_pos_light_space.xyz / frag_pos_light_space.w;<br>    <span class="hljs-comment">// transform to [0,1] range</span><br>    proj_coord = proj_coord * <span class="hljs-number">0.5</span> + <span class="hljs-number">0.5</span>;<br><br>    <span class="hljs-comment">// get depth of current fragment from light&#x27;s perspective</span><br>    <span class="hljs-type">float</span> current_depth = proj_coord.z;<br><br>    <span class="hljs-comment">// keep the shadow at 0.0 when outside the far_plane region of the light&#x27;s frustum.</span><br>    <span class="hljs-keyword">if</span> (current_depth &gt; <span class="hljs-number">1.0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// PCF</span><br>    <span class="hljs-type">float</span> shadow = <span class="hljs-number">0.0</span>;<br>    <span class="hljs-type">vec2</span> texel_size = <span class="hljs-number">1.0</span> / <span class="hljs-type">vec2</span>(<span class="hljs-built_in">textureSize</span>(shadow_map, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> x = <span class="hljs-number">-1</span>; x &lt;= <span class="hljs-number">1</span>; ++x)<br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> y = <span class="hljs-number">-1</span>; y &lt;= <span class="hljs-number">1</span>; ++y)<br>        &#123;<br>            <span class="hljs-type">float</span> pcf_depth = <span class="hljs-built_in">texture</span>(shadow_map, <span class="hljs-type">vec3</span>(proj_coord.xy + <span class="hljs-type">vec2</span>(x, y) * texel_size, layer)).r;<br>            shadow += current_depth &gt; pcf_depth ? <span class="hljs-number">1.0</span> : <span class="hljs-number">0.0</span>;<br>        &#125;<br>    &#125;<br>    shadow /= <span class="hljs-number">9.0</span>;<br>        <br>    <span class="hljs-keyword">return</span> shadow;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="效果对比"><a href="#效果对比" class="headerlink" title="效果对比"></a>效果对比</h1><h2 id="原先的阴影贴图"><a href="#原先的阴影贴图" class="headerlink" title="原先的阴影贴图"></a>原先的阴影贴图</h2><p>原先的阴影贴图只能覆盖有限的场景：<br><img src="/2024/10/13/cascade-shadow-map/sm_near.png"></p><p>提升覆盖范围后，阴影的质量则会出现下降：<br><img src="/2024/10/13/cascade-shadow-map/sm_far.png"></p><h2 id="级联阴影贴图"><a href="#级联阴影贴图" class="headerlink" title="级联阴影贴图"></a>级联阴影贴图</h2><p>采用级联阴影贴图可以覆盖很大的场景，并且在可控的性能消耗下仍然有不错的显示智联。<br><img src="/2024/10/13/cascade-shadow-map/csm_result.png"></p>]]></content>
    
    
    <categories>
      
      <category>技术漫谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D</tag>
      
      <tag>render</tag>
      
      <tag>渲染</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>程序化地形生成-1</title>
    <link href="/2024/10/11/ProceduralTerrainGeneration/"/>
    <url>/2024/10/11/ProceduralTerrainGeneration/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.shadertoy.com/">ShaderToy</a>是一个很有趣的网站，它上面有着非常多的渲染案例分享，最近一段时间我也是沉迷了。在看了不少大佬的作品之后，不禁手痒。前一段时间看了Inigo大佬的一个<a href="https://www.shadertoy.com/view/4ttSWf">教程案例</a>，想着把这个效果自己来实现一次，因此就有了今天的这篇文章。</p><p>我最终的成品也放到了shadertoy上面，有兴趣的同学可以一起讨论参考一下。看起来还不错对吧，虽然还有不少地方需要完善，但这个demo已经实现了我心中的大部分效果，包括无限的基于噪音的地形生成、地形阴影、雾气、云等等。</p><iframe width="640" height="360" frameborder="0" src="https://www.shadertoy.com/embed/4XByRV?gui=true&t=10&paused=true&muted=false" allowfullscreen></iframe><p>那么下面，就让我来一步步说明这个demo的实现过程吧。</p><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="在ST上渲染地形"><a href="#在ST上渲染地形" class="headerlink" title="在ST上渲染地形"></a>在ST上渲染地形</h2><p>对ShaderToy上运行的Shader代码，对应着可编程渲染管线的片段着色器(或者叫像素着色器)。片段着色器主要是是图形光栅化后的像素信息，所以渲染3D场景需要进行一些额外的步骤。</p><p>ShaderToy的程序一般是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mainImage</span><span class="hljs-params">(out vec4 fragColor, in vec2 fragCoord)</span><br>&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>fragColor</strong>是输出，代表这这个像素的最终颜色；<strong>fragCoord</strong>是输入，代表这个像素点的xy坐标。ShaderToy提供了固定变量<strong>iResolution</strong>用来表示整个屏幕的xy的分辨率。</p><p>为了渲染3D物体，我们需要采用ray cast&#x2F;marching的方法，构建一个相机的位置作为光线射出的起点<strong>ro</strong>，再根据当前像素点的坐标和ro的差获得光线射出的方向<strong>rd</strong>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">mainImage</span><span class="hljs-params">(out vec4 fragColor, in vec2 fragCoord)</span><br>&#123;<br>    vec2 uv = fragCoord / iResolution.xy;<br><span class="hljs-comment">// 以屏幕中心为（0,0）</span><br>    uv = uv * <span class="hljs-number">2.0</span> - <span class="hljs-number">1.0</span>;<br><span class="hljs-comment">// 缩放x，在画面拉伸的时候保证比例正确</span><br>    uv.x *= iResolution.x/iResolution.y;<br><span class="hljs-comment">// 原点位置</span><br>    vec3 ro = vec3(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-comment">// 射线方向</span><br>    vec3 rd = normalize(vec3(uv, <span class="hljs-number">2</span>));<br><br>fragColor = rayMarching(ro, rd);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="和地形相交"><a href="#和地形相交" class="headerlink" title="和地形相交"></a>和地形相交</h2><p>在shadertoy中渲染3D物体，一般是使用raymarching方法配合SDFs来渲染3D的物体。SDF（Signed Distance Field）是一种物体的隐式表达，用于存储和计算点到图形表面的最近距离。经由一个起点和一个方向，可以用SDF来达到低消耗的射线检测效果。</p><p>这里可以参考Inigo对SDF的介绍的介绍：<a href="https://iquilezles.org/articles/distfunctions/">https://iquilezles.org/articles/distfunctions/</a></p><p>地形的渲染也是类似的，我们通过ray marching方法来找到距离地形最近的点，以此来获取地形的形状。但是和SDF不同的是，我们无法很轻易的判断射线当前距离地形的最近距离，尤其是当我们的地形完全是通过噪音来随机生成的时候，这变成了一个不可能完成的任务。所以在判断地形相交的时候，只能回归到笨办法，一步一步慢慢的往前“挪”，<em>若当前的顶点在地形之下，而之前的一个迭代在地形之上的话</em>，那我们就找到了击中地表的区间段。<br><img src="https://iquilezles.org/articles/terrainmarching/gfx02.png" alt="射线和地表相交"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">rayMarch</span><span class="hljs-params">(vec3 ro, vec3 rd, out <span class="hljs-type">float</span> <span class="hljs-type">hit_t</span>)</span><br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> dt = <span class="hljs-number">0.01f</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> <span class="hljs-type">min_t</span> = <span class="hljs-number">1e-3</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">float</span> <span class="hljs-type">max_t</span> = <span class="hljs-number">1e3</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> t = <span class="hljs-type">min_t</span>; t &lt; <span class="hljs-type">max_t</span>; t+=dt)<br>&#123;<br><span class="hljs-type">const</span> vec3 p = ro+rd*t;<br><span class="hljs-keyword">if</span>(p.y &lt; f(p.x, p.z));<br>&#123;<br><span class="hljs-comment">// 取中间点减小误差</span><br><span class="hljs-type">hit_t</span> = t - <span class="hljs-number">0.5f</span>*dt;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法简单易懂，但显而易见在性能上并不是最优的，尤其是涉及到范围很大的地形的时候，dt的值如果取得太小，那么渲染完成一个场景的时间将会非常的长，消耗巨大；而若是dt的值取得太大，则很有可能会出现取值错误的情况。</p><p>当场景距离我们足够远的时候，由于透视的原因，近大远小，远处的场景精度对于观察者来说是越来越不重要了，因此dt的值可以随着光线步近而逐渐组建增大，动态变化。在合适的dt取值和变化曲线下，能够满足精度和性能的要求。Inigo给出的方法是类似这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//其他和上方代码一致</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> t = <span class="hljs-type">min_t</span>; t&lt;<span class="hljs-type">max_t</span>; t+=dt)<br>&#123;<br>    <span class="hljs-type">const</span> vec3 p = ro+rd*t;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> h = f(p.xz);<br>    <span class="hljs-keyword">if</span>(p.y&lt;h)<br>    &#123;<br>        <span class="hljs-type">hit_t</span> = t - <span class="hljs-number">0.5f</span>*dt;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    dt=<span class="hljs-number">0.01f</span>*t;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>t的起始值和dt的增长倍数可以自己尝试选择一个合适的值。</p><p>另外，如果我们能对最终渲染的效果有所了解的话，可以通过过滤掉很多不需要做射线检测的情况来极大的提升性能。如果我们最终的效果是一个在空中的相机，天空和地面占据画面各一半的话，那么上半部分的画面（通过rd.y&gt;0判断）是可以完全跳过射线检测的。或者通过增加min_t的值来减少前期昂贵且不必要的性能消耗。</p><p>在相交点的取值上，也可以进一步优化。原来仅仅是取两次光线步近的平均值，我们可以额外获取两次步近时位置的地形高度，用高度变化的连线和光线步近的线段做相交的判定取交点。这样得到的值将会更加精确。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//其他和上方代码一致</span><br><span class="hljs-type">float</span> lh = <span class="hljs-number">0.0f</span>;<br><span class="hljs-type">float</span> ly = <span class="hljs-number">0.0f</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">float</span> t = <span class="hljs-type">min_t</span>; t&lt;<span class="hljs-type">max_t</span>; t+=dt)<br>&#123;<br>    <span class="hljs-type">const</span> vec3 p = ro+rd*t;<br>    <span class="hljs-type">const</span> <span class="hljs-type">float</span> h = f(p.xz);<br>    <span class="hljs-keyword">if</span>(p.y&lt;h)<br>    &#123;<br>        <span class="hljs-comment">// 计算两个线段的相交点</span><br>        <span class="hljs-type">hit_t</span> = t - dt + dt*(lh-ly)/(p.y-ly-h+lh);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    dt=<span class="hljs-number">0.01f</span>*t;<br>    lh = h;<br>    ly = p.y;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br></code></pre></td></tr></table></figure><p>至此，我们就可以在ShaderToy渲染出地形了。</p><h1 id="地形生成"><a href="#地形生成" class="headerlink" title="地形生成"></a>地形生成</h1><h2 id="生成的基础：噪音"><a href="#生成的基础：噪音" class="headerlink" title="生成的基础：噪音"></a>生成的基础：噪音</h2><p>当我们提到噪音，往往会很生活化的把噪音和声音连接起来，从声学的角度来说是正确的。噪音其实可以用来表示所有通过振幅（amplitude）和频率（frequency）描述的波动，它可以是声音，它可以是辐射，也可以是其他的任意一种波动。</p><p>在数学课上，我们学过正弦、余弦等三角函数，sin和cos其实就是一种噪音的表现方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> amplitude = <span class="hljs-number">1.0</span>;<br><span class="hljs-type">float</span> frequencey = <span class="hljs-number">1.0</span>;<br><span class="hljs-type">float</span> y = amplitude * <span class="hljs-built_in">sin</span>(frequency * x);<br></code></pre></td></tr></table></figure><p>就像上面的代码所示，通过改变amplitude和frequency，我们可以改变sin波形的状态。</p><p>噪音在很多程序化生成算法中都有着举足轻重的地位。</p><h2 id="分形布朗运动"><a href="#分形布朗运动" class="headerlink" title="分形布朗运动"></a>分形布朗运动</h2><p>噪音是一种波，它是可以相互叠加的。两个相同的sin波形叠加会形成振幅更加强大的sin波形，而频率相差π&#x2F;2的两个sin波形叠加后会相互抵消。</p><p>在地形随机生成中，为了最终的结果噪音有着更好的随机性和更好的细节，将会循环多次计算噪音，循环的次数为我们称之为octave。每次循环的同一个噪音以一定倍数（lacunarity）升高频率，同时以一定比例（gain）降低振幅，最终将每个噪音计算的结果叠加得到一个最终的噪音，这个噪音的生成技术叫做“分形布朗运动”（fractal brownian motion，fbm）。</p><p>下面是分形布朗运动的一个简单的代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">float</span> <span class="hljs-title function_">fbm</span><span class="hljs-params">(vec2 uv, <span class="hljs-type">float</span> frequency, <span class="hljs-type">float</span> amplitude, <span class="hljs-type">int</span> octave)</span><br>&#123;<br><span class="hljs-type">float</span> lacunarity = <span class="hljs-number">2.0</span>;<br><span class="hljs-type">float</span> gain = <span class="hljs-number">0.5</span>;<br><span class="hljs-type">float</span> noise_val = <span class="hljs-number">0.0</span>;<br><span class="hljs-type">float</span> amp = amplitude;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> index = <span class="hljs-number">0</span>; index &lt; octave; ++index)<br>&#123;<br>nose_val += noiseInterpolate(uv * frequency) * amp;<br>amp *= gain;<br>frequency *= lacunarity;<br>&#125;<br><br><span class="hljs-keyword">return</span> noise_val;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中noiseInterpolate可以是perlin noise或者是simplex noise等任意一种噪音算法。<br>demo中的地形生成和云层的生成，也使用了该技术。关于FBM除了上面简单的使用还有很多其他的变种，这里我们就不扩展了，后面有机会的话可以专门介绍一下。</p><h2 id="地形的基础表现"><a href="#地形的基础表现" class="headerlink" title="地形的基础表现"></a>地形的基础表现</h2><p>这里我将地形部分拆解出来。demo的地形计算使用了perlin noise，octave数量达到了11。更多的octave数量会给地形带来更多的细节，但是一般来说后面的效果收益会越来越少。下方是octave数量分布为5和11下的地形的形状对比。<br><img src="/2024/10/11/ProceduralTerrainGeneration/shadertoy_oc5_noshadow.png"><br><img src="/2024/10/11/ProceduralTerrainGeneration/shadertoy_oc11_noshadow.png"></p><p>除了每次叠加噪音会进行频率和振幅的变化，为了获得更好的随机性，以及进一步减少噪音可能出现的重复pattern，可以将噪音进行旋转（也就是将传入的uv或者是坐标乘以一个默认的旋转矩阵）后再叠加到原来的噪音上。</p><p>我们也需要地形的法线来和光源结合，渲染出地形的明暗部分。获得法线的方法有很多种，可以采样当前计算的地形上点的x轴和z轴（这里假定y轴为up）方向不远的一两个点，和目标点相减得到切线和副切线方向，通过叉乘得到目标点的法线。亦或是采样其他点后通过中心差分法求得目标点的法线。</p><h2 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h2><p>仅仅通过法线来渲染地形的明部和暗部是不够的，我们还需要计算地形投射在地表上的阴影。地形的阴影计算原理非常简单，就是将地形上渲染的目标点，沿着光源方向进行射线检测，如果和地形相交的话，那该点就是处于阴影之下。理想情况下，射线检测的距离当然是实际上光源和地形上的点的距离，但是往往由于性能的原因，我们需要缩短这个距离。<em>实际的检测距离可以结合当前点的高度以及地形可能的最高位置进行计算</em>。</p><p>在判断当前点处于阴影的时候，计算最终颜色的时候需要再乘以一个阴影的系数。<br><img src="/2024/10/11/ProceduralTerrainGeneration/shadertoy_oc11_hardshadow.png"></p><p>为了提升效果，我们通常不希望阴影的边缘非常生硬，而是希望有一种柔软的过度，这种更加符合现实的表现。实现这种软阴影的方法可能有很多种，这里采用的是Inigo教程的一种方法。</p><p>上面提到判定阴影是通过从地形上面的点向光源方向做射线检测得到的，如果和地形相交则该点处于阴影当中，若不相交，则需要再取一个值，这值是地形向着光源方向移动距离t长度的位置，它和地形高度的差值d和距离t的比值的最小值，乘以某个常数X（10~32等等，可以自己尝试合适的范围）后经过smoothstep限制在（0,1）范围内。这个值作为阴影系数放入光照计算后就可以得到不错的软阴影效果。<br><img src="/2024/10/11/ProceduralTerrainGeneration/calc_soft_shadow.png"></p><p>通过下面的对比图我们可以看到，在加入了软阴影计算后，地形阴影的边缘有了一种较为平滑的过度，显得没那么生硬了。想要更改软阴影的表现的话可以通过修改常数X。<br><img src="/2024/10/11/ProceduralTerrainGeneration/shadertoy_terrain.png"></p><h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>好了，我们已经得到了一个基础的程序化生成地形的效果了，但是它看起来还是有些单调。地形的深度表现、天空、云彩等等应该如何表现呢？</p><p>无需着急，我们将会在后面的文章中对它进行进一步的优化。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://thebookofshaders.com/13/?lan=ch">https://thebookofshaders.com/13/?lan=ch</a><br><a href="https://iquilezles.org/articles/morenoise">https://iquilezles.org/articles/morenoise</a><br><a href="https://youtu.be/BFld4EBO2RE?si=HWQMSNx5TBsOG_6g">https://youtu.be/BFld4EBO2RE?si=HWQMSNx5TBsOG_6g</a></p>]]></content>
    
    
    <categories>
      
      <category>技术漫谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>3D</tag>
      
      <tag>render</tag>
      
      <tag>渲染</tag>
      
      <tag>编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人博客启动</title>
    <link href="/2024/10/09/StartMyBlog/"/>
    <url>/2024/10/09/StartMyBlog/</url>
    
    <content type="html"><![CDATA[<p>晚上好。</p><p>还是打算在个人的github.io继续更新自己的技术博客了。<a href="qrc-eye.com">原网站</a>本来是打算用于和朋友一起写点东西上去的，结果现在倒是变成了只有我自己的碎碎念，着实不太好。</p><p>最近一段时间会尽快的将我的部分文章搬运过来，一些琐碎的文章暂时就不管了。</p>]]></content>
    
    
    <categories>
      
      <category>生活杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
